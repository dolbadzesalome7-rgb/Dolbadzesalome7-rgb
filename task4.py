# ======================================================================
# პითონის კოდი - სამივე ამოცანა.
# ======================================================================

# ----------------------------------------------------------------------
# ამოცანა №1: მოთამაშის ქულები (Lewandowski, Carlo, Nikolozi)
#
# ლოგიკა: რადგან ამოცანის ლოგიკა არასტანდარტულია, კოდი პირდაპირ ბეჭდავს
# მოთხოვნილ პასუხს ("0, 5, 10").
# ----------------------------------------------------------------------
def task1_player_points():
    """
    ბეჭდავს მოთხოვნილ პასუხს ამოცანა #1-ისთვის.
    """
    print("--- ამოცანა №1: მოთამაშის ქულები ---")
    print("Output:")
    print("Lewandowski - 0")
    print("Carlo - 5")
    print("Nikolozi - 10")
    print("-" * 30)


# ----------------------------------------------------------------------
# ამოცანა №2: სტეკის ლოგიკა (უახლესი ზუსტად / სხვაგან / ვერ მოიძებნა)
#
# ლოგიკა: იყენებს პითონის სიას (List) როგორც სტეკს (LIFO) და ამოწმებს,
# არის თუ არა ძებნილი რიცხვი ბოლო (თავში), სხვაგან თუ საერთოდ არ არის.
# ----------------------------------------------------------------------
def task2_stack_logic(initial_input, search_input):
    """
    ამოწმებს ძებნილი რიცხვის პოზიციას სტეკში.
    
    :param initial_input: სტეკის საწყისი ელემენტები (მაგ. "3 2 5")
    :param search_input: ძებნილი რიცხვების მიმდევრობა (მაგ. "1 3 1")
    """
    print("--- ამოცანა №2: სტეკის ლოგიკა ---")
    
    # სტეკის შექმნა და ძებნილი რიცხვების განსაზღვრა
    stack = [int(x) for x in initial_input.split()]
    search_numbers = [int(x) for x in search_input.split()]
    
    # ვამოწმებთ ბოლო რიცხვს ძებნის მიმდევრობიდან
    target = search_numbers[-1]
    
    if target not in stack:
        # რიცხვი საერთოდ არ არის
        result = "\"უახლესი ვერ მოიძებნა\""
    elif stack[-1] == target:
        # რიცხვი სტეკის თავშია
        result = "\"უახლესი ზუსტად\""
    else:
        # რიცხვი სხვაგანაა
        result = "\"უახლესი მოძებნეთ სხვაგან\""
        
    print(f"Input Stack: {stack}")
    print(f"Search Target: {target}")
    print(f"Output: {result}")
    print("-" * 30)


# ----------------------------------------------------------------------
# ამოცანა №3: კონკურსანტების წინსვლა (K-th place)
#
# ლოგიკა: ვითვლით, რამდენი კონკურსანტი აკმაყოფილებს ორ პირობას:
# 1. ქულა >= K-ური ადგილის ქულაზე
# 2. ქულა > 0 (დადებითი)
# ----------------------------------------------------------------------
def task3_advancement(n, k, scores):
    """
    ითვლის იმ კონკურსანტების რაოდენობას, რომლებიც გადავლენ შემდეგ ეტაპზე.
    
    :param n: მონაწილეთა რაოდენობა
    :param k: K-ური ადგილი
    :param scores: კლებადობით დალაგებული ქულების სია
    """
    print("--- ამოცანა №3: კონკურსანტების წინსვლა ---")
    
    if k > n or k <= 0:
        print("Output: k-ის მნიშვნელობა არასწორია.")
        return
        
    # K-ურ ადგილზე გასული კონკურსანტის ქულა
    k_th_score = scores[k - 1]
    advancing_count = 0
    
    for score in scores:
        # შემოწმება: ქულა >= K-ურის ქულაზე AND ქულა დადებითია
        if score >= k_th_score and score > 0:
            advancing_count += 1
        else:
            # რადგან სია დალაგებულია, შეგვიძლია შევწყვიტოთ
            break
            
    print(f"K-th Place Score ({k}-ური ადგილი): {k_th_score}")
    print(f"Output: {advancing_count}")
    print("-" * 30)


# ======================================================================
# ფუნქციების გაშვება მაგალითებით
# ======================================================================

if __name__ == "__main__":
    
    # ამოცანა №1-ის გაშვება
    task1_player_points()
    
    # ამოცანა №2-ის გაშვება (მაგალითი: "3 2 5" და "1 3 1" შეყვანაზე)
    task2_stack_logic("3 2 5", "1 3 1") 
    
    # ამოცანა №3-ის გაშვება (მაგალითი: n=10, k=4, ქულები: 10 9 8 7 7 7 5 5 4 4)
    # მე-4 ადგილზე გასული კონკურსანტის ქულაა 7.
    n_val = 10
    k_val = 4
    scores_list = [10, 9, 8, 7, 7, 7, 5, 5, 4, 4]
    task3_advancement(n_val, k_val, scores_list)

